// Copyright (c) 2021 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description:
:seo-title:
:seo-description:
:page-layout: general-reference
:page-type: general
= Manage database transaction recovery with the transaction service

The Open Liberty transaction service writes information to a transaction log for every global transaction that involves two or more resources, or that is distributed across multiple servers. You can configure the transaction service to control when and how database transactions are recovered after a server failure.

The transaction service maintains transaction logs to ensure the integrity of transactions. Information is written to the transaction logs in the prepare phase of a distributed transaction. If a server with active transactions restarts after a failure, the transaction service is able to use the logs to replay any indoubt transactions. This process allows the overall system to be brought back to a consistent state after a server failure.

The Open Liberty transaction service is activated by default when you enable features that use transactions, such as feature:jpa[display=Java persistence API ], feature:jdbc[display=Java database connectivity], or feature:wasJmsServer[display=Message server]. Although the transaction service is implemented with sensible defaults, you can configure when database transaction recovery occurs and how database transactions are recovered by specifying the `transaction` element in your `server.xml` file. You can also choose to store your transaction logs in a relational database rather than as operating system files by configuring a dedicated, non-transactional data source to store the logs in.

== Transaction service configuration

If you enable any Open Liberty features that use transactions, you can configure how the transaction service manages transaction recovery by specifying the `transaction` element in your `server.xml` file.
For example, you can configure when transaction recovery occurs. By default, transaction recovery after a server failure happens when the transaction service is first used rather than at server startup. You can alter this behavior by specifying `transaction` element attributes. For more information about the available attributes, see config:transaction[display=Transaction Manager].

In the following `server.xml` example, the `recoverOnStartup` attribute for the `transaction` element specifies that transaction recovery occurs at server startup:

[source,xml]
----
<transaction
  recoverOnStartup="true"
  totalTranLifetimeTimeout="300s"
  propogatedOrBMTTranLifetimeTimeout="300s"
  heuristicRetryWait="0"
  acceptHeuristicHazard="false"
/>
----

The `totalTranLifetimeTimeout` attribute sets the maximum time for transactions that are started on this server to complete. The `propogatedOrBMTTranLifetimeTimeout` attribute sets the upper limit of the transaction timeout for transactions that run in this server. In this example, both values are set to  300 seconds.

The `0` value for the `heuristicRetryWait` attribute specifies that the server does not retry a completion signal, such as a commit or rollback. By default, up to 5 retries occur after a transient exception from a resource manager or remote partner.

Setting the `acceptHeuristicHazard` attribute to `false` specifies that not all applications on this server accept the possibility of heuristic hazard in a two-phase transaction that contains a one-phase resource.

== Authorization precedence for database transaction recovery

When the Open Liberty transaction service recovers indoubt database transactions, it uses either the unique identifier or the JNDI name of the data source to locate the current `dataSource` element. The service then determines the user ID and password to use for recovery based on the configuration of that element in the `server.xml` file.

The data source user ID and password to use for recovery are determined according to the following order of precedence:

. If the `dataSource` element defines the `recoveryAuthDataRef` attribute, then the user ID and password from the `authData` element are used.
+
The following example shows an `authData` element that defines a user ID and password. The `dataSource` element references this `authData` element in a `recoveryAuthDataRef` attribute:
+
[source,xml]
----
<authData id="recoveryAuth" user="dbuser1" password="{xor}Oz0vKDtu"/>
<dataSource id="ds1" jndiName="jdbc/ds1" jdbcDriverRef="DB2"
            recoveryAuthDataRef="recoveryAuth" .../>
----

. If container-managed authentication is used, then the user ID and password from the container-managed authentication alias are used.

. If no `recoveryAuthDataRef` attribute is specified and container-managed authentication is not configured, the user ID and password from the `dataSource` element are used. +
The following example shopws a data source configuration for a Db2 database, where the user ID and password are specified in vendor-specific attributes on the `dataSource` element:
+
[source,xml]
----
<dataSource id="ds1" jndiName="jdbc/ds1" jdbcDriverRef="DB2" ...>
     <properties.db2.jcc databaseName="testdb" user="dbuser1" password="{xor}Oz0vKDtu"/>
</dataSource>
----
+
. If none of the previous conditions are satisfied, the recovery is attempted without any user ID and password and the behavior is determined by the configured JDBC driver and data source.

You must not change the value of the `id` or `jndiName` data source attributes when a recovery is pending for a transaction in which the data source participated. If you change any other attributes of the `dataSource` element, those changes are retained for the recovery. For example, you can add a `recoveryAuthDataRef` attribute that specifies a data source user ID and password to use for recovery.

If transactions are recovered by an application-defined data source, such as an `@DataSourceDefinition` annotation or a `data-source` element in a deployment descriptor file, you must ensure that the associated application is running when the recovery occurs. You cannot use configuration settings in the `server.xml` file to recover application-defined data sources.

For more information about data source configuration, see xref:relational-database-connections-JDBC.adoc#_data_source_configuration[Data source configuration].

== Transaction log management

You can store your Open Liberty transaction logs in a relational database rather than as operating system files. This feature provides high availability (HA) support without having to use a shared file system. Storing transaction service logs in a relational database is supported for production use.

By default, the transaction service stores transaction logs as operating system files. This HA transaction support requires the use of a shared file system to host the transaction logs, such as an NFSv4-mounted network-attached storage (NAS) or a storage area network (SAN).
However, you can choose to store the transaction logs in a relational database management system (RDBMS) instead. With this feature, you can use your existing HA database as a shared repository for the transaction logs, as an alternative to using a shared file system. You can use any database type that Open Liberty supports.

To configure the Open Liberty transaction logs to be stored in an RDBMS, you can configure a dedicated, non-transactional data source in your `server.xml` file. Specify the data source configuration inside an instance of the `transaction` element, as shown in the following example:

[source,xml]
----
<transaction>
  <dataSource transactional="false">
    <jdbcDriver libraryRef="DB2JCC4LIB"/>
    <properties.db2.jcc currentSchema="CBIVP"
      databaseName="SAMPLE" driverType="4"
      portNumber="50000" serverName="localhost"
      user="db2admin" password="{xor}Oz1tPjsyNjE=" />
  </dataSource>
</transaction>

<library id="DB2JCC4LIB">
  <fileset dir="C:/SQLLIB/java" includes="db2jcc4.jar db2jcc_license_cu.jar"/>
</library>
----
You can configure an Open Liberty server to recover the logs of a different application server. The original owning application server must not be running when you use this procedure. It is typically employed to perform any outstanding transactional recovery when the transaction service logs are available but the original owning application server cannot be started.

If you store transaction logs in an RDBMS, each server must have its own tables. You can specify a unique table suffix by using the `transactionLogDBTableSuffix` attribute for the `transaction` element. The value for this attribute is a string that is post-pended to the table name to make it unique to the server where the table is hosted.

=== Manual configuration of database tables
Optionally, you can create the database tables manually. Open Liberty attempts to create the necessary database tables when the server first starts. If it cannot create these databases, due to insufficient permission for example, the server fails to start. Under these circumstances, you must create the two database tables manually.

The following sections provide example data definition language (DDL) structures to create tables and indexes for commonly used database vendors:

- <<#db2,Db2>>
- <<#oracle,Oracle>>
- <<#postgreSQL,postgreSQL>>
- <<#microsoft,Microsoft SQL Server>>

[#db2]
=== Db2

The following DDL structures show how to create the tables on Db2:

[source,SQL]
----
CREATE TABLE OL_TRAN_LOG(
  SERVER_NAME VARCHAR(128),
  SERVICE_ID SMALLINT,
  RU_ID BIGINT,
  RUSECTION_ID BIGINT,
  RUSECTION_DATA_INDEX SMALLINT,
  DATA BLOB)
----

[source,SQL]
----
CREATE TABLE OL_PARTNER_LOG(
  SERVER_NAME VARCHAR(128),
  SERVICE_ID SMALLINT,
  RU_ID BIGINT,
  RUSECTION_ID BIGINT,
  RUSECTION_DATA_INDEX SMALLINT,
  DATA BLOB)
----

The following DDL structures show how to create the tables on the old DB2 version:

[source,SQL]
----
CREATE TABLE OL_TRAN_LOG(
  SERVER_NAME VARCHAR(128),
  SERVICE_ID SMALLINT,
  RU_ID BIGINT,
  RUSECTION_ID BIGINT,
  RUSECTION_DATA_INDEX SMALLINT,
  DATA LONG VARCHAR FOR BIT DATA)
----

[source,SQL]
----
CREATE TABLE OL_PARTNER_LOG(
  SERVER_NAME VARCHAR(128),
  SERVICE_ID SMALLINT,
  RU_ID BIGINT,
  RUSECTION_ID BIGINT,
  RUSECTION_DATA_INDEX SMALLINT,
  DATA LONG VARCHAR FOR BIT DATA)
----

The following DDL structures show how to create indexes for these tables:

[source,SQL]
----
CREATE INDEX IXOLTRAN_LOG ON OL_TRAN_LOG (RU_ID ASC, SERVICE_ID ASC, SERVER_NAME ASC)
CREATE INDEX IXOLPARTNER_LOG ON OL_PARTNER_LOG (RU_ID ASC, SERVICE_ID ASC, SERVER_NAME ASC)
----

[#oracle]
=== Oracle

The following DDL structures show how to create the database table on Oracle:

[source,SQL]
----
CREATE TABLE OL_TRAN_LOG(
  SERVER_NAME VARCHAR(128),
  SERVICE_ID SMALLINT,
  RU_ID NUMBER(19),
  RUSECTION_ID NUMBER(19),
  RUSECTION_DATA_INDEX SMALLINT,
  DATA BLOB)
----

[source,SQL]
----
CREATE TABLE OL_PARTNER_LOG(
  SERVER_NAME VARCHAR(128),
  SERVICE_ID SMALLINT,
  RU_ID NUMBER(19),
  RUSECTION_ID NUMBER(19),
  RUSECTION_DATA_INDEX SMALLINT,
  DATA BLOB)
----

The following DDL structures show how to create indexes for these tables:

[source,SQL]
----
CREATE INDEX IXOLTRAN_LOG ON OL_TRAN_LOG ( "RU_ID" ASC, "SERVICE_ID" ASC, "SERVER_NAME" ASC)
CREATE INDEX IXOLPARTNER_LOG ON OL_PARTNER_LOG ( "RU_ID" ASC, "SERVICE_ID" ASC, "SERVER_NAME" ASC)
----

[#postgreSQL]
=== PostgreSQL

The following DDL structures show how to create the database table on postgreSQL:

[source,SQL]
----
CREATE TABLE OL_TRAN_LOG (
SERVER_NAME VARCHAR(128),
SERVICE_ID SMALLINT,
RU_ID BIGINT,
RUSECTION_ID BIGINT,
RUSECTION_DATA_INDEX SMALLINT,
DATA BYTEA)
----

[source,SQL]
----
CREATE TABLE OL_PARTNER_LOG (SERVER_NAME VARCHAR(128),
SERVICE_ID SMALLINT,
RU_ID BIGINT,
RUSECTION_ID BIGINT,
RUSECTION_DATA_INDEX SMALLINT,
DATA BYTEA)
----

The following DDL structures show how to create indexes for these tables:

[source,SQL]
----
CREATE INDEX IXOLTRAN_LOG ON OL_TRAN_LOG ( RU_ID ASC, SERVICE_ID ASC, SERVER_NAME ASC)
CREATE INDEX IXOLPARTNER_LOG ON OL_PARTNER_LOG ( RU_ID ASC, SERVICE_ID ASC, SERVER_NAME ASC)
----

[#microsoft]
=== Microsoft SQL Server

The following DDL structures show how to create the database table on Microsoft SQL Server:

[source,SQL]
----
CREATE TABLE OL_TRAN_LOG (
SERVER_NAME VARCHAR(128),
SERVICE_ID SMALLINT,
RU_ID BIGINT,
RUSECTION_ID BIGINT,
RUSECTION_DATA_INDEX SMALLINT,
DATA VARBINARY(MAX))
----

[source,SQL]
----
CREATE TABLE OL_PARTNER_LOG (
SERVER_NAME VARCHAR(128),
SERVICE_ID SMALLINT,
RU_ID BIGINT,
RUSECTION_ID BIGINT,
RUSECTION_DATA_INDEX SMALLINT,
DATA VARBINARY(MAX))
----

The following DDL structures show how to create indexes for these tables:

[source,SQL]
----
CREATE INDEX IXOLTRAN_LOG ON OL_TRAN_LOG ( "RU_ID" ASC, "SERVICE_ID" ASC, "SERVER_NAME" ASC)
CREATE INDEX IXOLPARTNER_LOG ON OL_PARTNER_LOG ( "RU_ID" ASC, "SERVICE_ID" ASC, "SERVER_NAME" ASC)
----
