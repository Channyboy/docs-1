// Copyright (c) 2021 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description: Open Liberty supports two JMX connectors, local connector and REST connector.
:seo-title: Designing cloud-native microservices
:seo-description: Open Liberty supports two JMX connectors, local connector and REST connector.
:page-layout: general-reference
:page-type: general
= Differences between MicroProfile Config versions

Two key sets of changes might impact existing configuration when you upgrade from MP Config 1.x->2.0:

== SmallRye implementation of the specification

Open Liberty implements the MicroProfile Config specification for application configuration from different ConfigSources.
In previous versions, OpenLiberty implemented the specification in its own codebase.
However, for MicroProfile Config 2.0, Open Liberty consumes SmallRye implementation of the specification.
This means that any MicroProfile Config functionality that Open Liberty implemented beyond the scope of the specification will be lost from 1.x->2.0.


* Converters for the `AtomicInteger` and `AtomicLong` properties are no longer provided, because these properties are not widely used.
Converting an injected value to one of these types of properties may throw the following exception:
SRCFG02006: The property `yourProperty` cannot be converted to class `java.util.concurrent.atomic.AtomicInteger/AtomicLong`.
If you need to convert a string from `AtomicInteger` to `AtomicLong`, you can convert to `Integer` or `Long` and then create an `AtomicIneger` or `AtomicLong` string.
Alternatively, you can create your own converter for `AtomicInteger` or `AtomicLong`.

** In MP Config 1.x, converters were provided for `AtomicInteger` and `AtomicLong`.

* In MP Config 2.0, caching is discontinued.
  Values looked up from Config are no longer cached.

** In MP Config 1.x, requests made for the same config key returned the same object up to five seconds duration, without calling the config sources.


* When a converter for a specific type is not available, converters its subtypes are cannot be used.
For example, in MP Config-1.x if a converter was registered for the type `Dog` variable which extends a type `Animal` variable, then a type `Animal` variable was injected, which used the Dog converter, e.g.

[source,java]
----
@Inject
@ConfigProperty(name = "DOG_KEY")
Animal myAnimal;
----
The recommended approach is to use the above converter to convert to Dog, which is essentially an Animal.

** Converters for subtypes were available for MP Config 1x


* The number of recursion lookups is limited for composed expressions.
Implementations are generally limited to 5, but can be higher.
When the number of allowed lookups exceeds the limit, an `IllegalArgumentException` is thrown.
Variable replacement in config values is supported through Property Expressions.
This allows config values to reference other config property values using the `${}` syntax with a maximum recursive depth of 32.

== Incompatible changes

Changes in the MP Config specification from 1.4->2.0 introduced some incompatibility changes.
Some of these changes are by-products of new features, and others are intentional specification clarifications and changes.

- `ConfigSource.getPropertyNames()` is no longer a default method provided by the specification.
Any custom Config Sources which use this method will need to implement the method, otherwise a `java.lang.AbstractMethodError` will be thrown.

- Property Expression is a new feature which may impact existing configurations.
From mpConfig 2.0 Config Properties can include references to other Config Properties by using the following syntax: `${anotherConfigPropertyName}`.
As such, any Config Properties which contain values with Property Expression syntax may behave differently.

- Config Property value conversion rules have been updated such that the empty value and other special characters are no longer valid values for particular return types.
Attempting to call `getValue()` on an injected empty value ("") for type String for example will throw a `java.util.NoSuchElementException`.
