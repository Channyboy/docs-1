:page-layout: intro
:page-description: Concept for JSON-B
:page-categories: REST
:page-permalink: /docs/concept/col_JSON.html
= JSON-B for serializing and deserializing Java objects

JSON-B is a standard API for converting plain Java objects (POJOs) to and from JSON data. It defines a default mapping for most types in the JavaSE platform, and allows users to customize the mapping process for direct control over the marshaling and unmarshaling process.

== Introduction to JSON-B

JavaScript Object Notation (JSON) has established itself as the data language of microservices.  It is less verbose than XML, but still human readable.  Nevertheless, the Java language has not had a spec-defined technology for easily converting JSON data to and from Java objects.  JSON-B (https://jcp.org/en/jsr/detail?id=367[JSR-367]) allows users to quickly and easily convert Java objects to JSON data - in most cases without any changes to the Java model classes. Annotations allow for easy customization of things like JSON property names, optional properties, or provide advanced methods to modify the data during transformation.

Combined with other technologies, like JAX-RS, the conversion between JSON and Java objects are even more seamless. Let's take a closer look at what JSON-B can do.

== When to use JSON-B and JSON-P

JSON-B is a higher level programming model can be used with much less code than JSON-P, and that makes it easier to use than JSON-P. JSON-B is a direct object-to-JSON mapping. JSON-P maps via APIs like JsonObject/JsonArray/etc, and therefore, is more manual. However, it still supports cross-domain requests.

JSON-B has an object-binding API that supports direct object mapping to and from JSON representations. Java Architecture for XML Binding (JAXB) functions in this way, given the way that XML data is formatted in Java. JAXB is a collection of APIs that are used to bind XML schemas to Java objects and vice versa. For instance, in JAXB, the annotations API (javax.xml.bind.annotation) is used to bind Java elements to XML schemas. There's a https://dzone.com/articles/jsonb-java-api-for-json-binding[JSON-B article on DZone] that goes into more detail about why JSON-B is the preferred choice.

== How to enable JSON-B

In OpenLiberty, simply enable the `jsonb-1.0` feature in server.xml:
[source,xml]
----
<server>
  <featureManager>
    <feature>jsonb-1.0</feature>
    <!-- other features... -->
  </featureManager>
</server>
----

Also, add the JSON-B API as a provided maven dependency:
[source,xml]
----
<dependency>
    <groupId>javax.json.bind</groupId>
    <artifactId>javax.json.bind-api</artifactId>
    <version>1.0</version>
    <scope>provided</scope>
</dependency>
----


== Basic usage of JSON-B

Suppose we have the following data class:
[source,java]
----
public static class User {

    // Public fields will get be included in the JSON data
    public String id;
    public Set<String> roles;
    public String name;
    public int age;

    // Private fields do not get included in the JSON data
    private String somethingSecret = "shhhhh";

    public User() {
    }

    public User(String id, String name, int age, Set<String> roles) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.roles = roles;
    }
}
----

Note that the data class does not have any annotations or any reference to JSON-B API. We can rely on the default mappings of JSON-B to marshal and unmarshal the object for us. The main JSON-B entry point is the `Jsonb` class. It provides all necessary methods to serialize and deserialize Java objects. `Jsonb` instances are thread safe. They can be cached and reused.  

[source,java]
----
// Always cache Jsonb objects when possible! They are relatively expensive to create
private static final Jsonb jsonb = JsonbBuilder.create();
// ...

// Convert POJO --> JSON
User andy = new User("1234", "Andy", 77, Collections.singleton("admin"));
String andyJson = jsonb.toJson(andy);
System.out.println(andyJson); // prints: {"age":77,"id":"1234","name":"Andy","roles":["admin"]}

// Convert JSON --> POJO
String jsonData = "{\"age\":55,\"id\":\"5678\",\"name\":\"Hank\",\"roles\":[\"member\"]}";
User hank = jsonb.fromJson(jsonData, User.class);
----

== Customize mappings

By default, JSON property names match Java field/method names, but if this is not desired or possible, new mappings can be defined:
[source,java]
----
// maps the 'name' field to the 'fullName' JSON property
@JsonbProperty("fullName")
public String name;

// even though the field is public, tell JSON-B to ignore this field so it is not included in the JSON output
@JsonbTransient
public Set<String> roles;
----

== Using JSON-B through JAX-RS

JSON-B works very well with JAX-RS because JAX-RS resources often consume or produce JSON data over HTTP, but within endpoints want to interact with the data as POJOs.

[source,java]
----
@Path("/player")
@ApplicationScoped
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class UserService {

    @Inject
    UserDB db;

    @GET
    @Path("/{userId}")
    public User getUserById(@PathParam("userId") String id) {
        User u = db.get(id);
        return u;
        // returned User object will be converted to JSON data using JSON-B
    }

    @POST
    @Path("/{userId}")
    public String createUser(User updatedUser, @PathParam("userId")) {
        // The incoming 'updatedUser' parameter gets read from the incoming 
        // request body's JSON data and automatically converted to a User object
        updatedUser.id = // generate an ID
        db.save(updatedUser);
        return updatedUser.id;
    }
}
----

== Where to next?

Now that youâ€™ve seen how JSON-B works, you can learn how to create a RESTful web service using JSON-B to ! Check out the https://openliberty.io/guides/?search=REST&key=tag[REST guides] written by our team. Launch your next RESTful service today!

