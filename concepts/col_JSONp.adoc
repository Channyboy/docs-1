:page-layout: intro
:page-description: Concept for JSON-B
:page-categories: REST
:page-permalink: /docs/concept/col_JSON.html
= JSON-B for serializing and deserializing Java objects

JSON-B is a standard binding layer for converting Java objects. It defines a default mapping algorithm for converting existing Java classes to JSON messages.

== Introduction to JSON-B

JavaScript Object Notation (JSON) has established itself as the data language of microservices.  It is less versbose than XML, but still human readable.  Nevertheless, the Java language has not had a spec-defined technology for easily converting JSON into a Java object and vice versa.  Enter JSON-B.  JSON-B (https://jcp.org/en/jsr/detail?id=367[JSR-367]) allows users to quickly and easily convert objects to JSON - in some cases without any changes to the Java model classes.  It maps Java objects to JSON objects.  Easy-to-understand annotations make it easy to modify the JSON property name, make some properties optional, or provide advanced methods to modify the data during transformation.

Combined with other technologies, like JAX-RS, the conversion between JSON and Java objects are even more seamless. Let's take a closer look at what JSON-B can do.

== Why JSON-B is better than JSON-P

*Placeholder text* Microservice architecture is a popular approach for building cloud-native applications so that each component is an individual service that fulfills a specific purpose. It enables small, autonomous teams to develop, deploy, and scale their respective services independently. One benefit is that the application can be scaled on a more granular level because each service is built and managed independently. The high-traffic services can be individually scaled to efficiently use resources rather than scaling up the entire system. Another benefit is that failures in one service can be isolated from the rest of the system; if a service fails, services that are independent are unaffected while dependent services can employ fault tolerance strategies to prevent the failure from cascading to other services.

== Examples of JSON-B in action 

=== Add Maven repositories
Add these repositories to your Maven project first:
----
<repositories>
    <!-- Needed for JSON-B API -->
    <repository>
        <id>java.net-Public</id>
        <name>Maven Java Net Snapshots and Releases</name>
        <url>https://maven.java.net/content/groups/public/</url>
    </repository>
</repositories>
----

=== Add some dependencies
Now, add these dependencies to the repository that you created: 
----
<dependency>
    <groupId>javax.json.bind</groupId>
    <artifactId>javax.json.bind-api</artifactId>
    <version>1.0</version>
</dependency>
                    
<dependency>
    <groupId>org.eclipse</groupId>
    <artifactId>yasson</artifactId>
    <version>1.0</version>
</dependency>

<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>javax.json</artifactId>
    <version>1.1</version>
</dependency>
----

=== Map an object
The main JSON-B entry point is `Jsonb` class. It provides all necessary methods to serialize and deserialize Java objects. `Jsonb` instances are thread safe. They can be cached and reused.  
----
<dependency>
    <groupId>javax.json.bind</groupId>
    <artifactId>javax.json.bind-api</artifactId>
    <version>1.0</version>
</dependency>
                    
<dependency>
    <groupId>org.eclipse</groupId>
    <artifactId>yasson</artifactId>
    <version>1.0</version>
</dependency>

<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>javax.json</artifactId>
    <version>1.1</version>
</dependency>
----

=== Map a collection
JSON-B supports collections and generic collections handling. For proper deserialization the runtime type of resulting object needs to be passed to JSON-B during deserialization. It can be done a way shown below. 
----
// List of dogs
List<Dog> dogs = new ArrayList<>();
dogs.add(falco);
dogs.add(cassidy);

// Create Jsonb and serialize
Jsonb jsonb = JsonbBuilder.create();
String result = jsonb.toJson(dogs);

// Deserialize back
dogs = jsonb.fromJson(result, new ArrayList<Dog>(){}.getClass().getGenericSuperclass());
----

=== Customize mappings
You can customize mappings in lots of different ways. You can use JSON-B annotations for compile time customizations and JsonbConfig class for runtime customizations. The following sample includes the creation of a custom configuration that serializes null values. By default, class properties with null values are ignored. 
----
// Create custom configuration
JsonbConfig nillableConfig = new JsonbConfig().withNullValues(true);

// Create Jsonb with custom configuration
Jsonb jsonb = JsonbBuilder.create(nillableConfig);

// Use it!
String result = jsonb.toJson(pojo);
----

== Where to next?

Now that youâ€™ve seen how JSON-B works, you can learn how to create a RESTful web service using JSON-B to ! Check out the https://openliberty.io/guides/?search=REST&key=tag[REST guides] written by our team. Launch your next RESTful service today!

